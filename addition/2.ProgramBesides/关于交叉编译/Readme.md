# 说明

## 是什么

人话：交叉编译就是使用本地设备、交叉编译工具链在本地编译一个工程，然后把编译结果移植到目标平台，然后运行，如此就完成了一次交叉编译；在后来与同僚的交流中我进一步发现，交叉编译确确实实分为两种风格，一种是只使用GCC工具链的交叉编译，整个过程只需要考虑使用gcc、g++，当文件稍微复杂一点时，可以考虑使用makefile，另一种是使用交叉编译GCC工具链生成编译工具之后再用这个交叉编译工具完成交叉编译工作，例如交叉编译的qmake和cmake，它们自带了交叉编译gcc工具链的信息、编译结果的动态库、静态库存放路径等信息。

官话：[嵌入式开发 | 什么是交叉编译(CROSS_COMPILE)](https://zhuanlan.zhihu.com/p/77116555)，目前没发现有什么系统级的教程，随便找点网络帖子吧。

唠叨：说得直白一点，平时我们使用的gcc是x86的，本地编译，本地执行，交叉编译过程中使用的gcc是目标平台的，例如本作品就是loongarch64的，它可以在x86平台上运行，并生成可以在loongarch64平台上运行的可执行文件，但是这个过程只涉及简单的可执行文件，如果我编译一个可以在loongarch64上运行的GUI软件，就需要使用Qt，以及自己制作一个用交叉编译gcc生成的qmake，那么这个qmake也能在x86上运行，并生成一个可以在loongarch64上运行的GUI软件，这样一个qmake则是自己用``x86-loongarch-gcc``工具链编译生成的可执行文件，编译过程依然为make过程，使用本地make。

## 怎么做

人话：首先获取目标平台的交叉编译专用工具链，然后下载Qt的源码，将Qt源码内的.conf文件中的编译器类型修改为目标平台的交叉编译工具链，这要求Qt官方支持目标平台的qmake编译，而本作品用到的龙芯派则根本不被Qt官方支持（本人已经遍历Qt众多版本，未果，Qt4.8只支持mips而不是loongarch64），只能使用由龙芯官方提供的``qmake5.15.2``，说起来这个版本还比最大能离线安装的版本高级，使用官方发布的.sh文件安装即可。如果是树莓派，则可以去下载linaro的交叉编译工具链，比普通的arm交叉编译工具链多一个hf作为后缀，然后在qt源码中找到这个平台的分类并修改它使用的交叉编译工具链的路径即可完成qmake的编译，当然前提还要从树莓派系统上获取sysroot环境，它给qmake提供了一个模拟目标环境的临时小环境，这样才能完成用qmake进行交叉GUI编译。详情见[关于Qt](../../../demo/关于Qt/Readme.md)文档。

官话：无

唠叨：其实整个操作过程都是我靠野生的网络资源形成的认识，目前还没看到几个对交叉编译有系统讲解的书籍，也许存在一些arm交叉编译的教程，但那是最简单的交叉编译了，即仅使用交叉编译gcc工具链而不是配置交叉编译qmake，如果是这样的话，是没办法写嵌入式Linux的图形化界面的，更不要提用嵌入式Linux本地编译GUI，那样更加愚蠢（一是时间漫长，二是MCU不一定自带qmake）

## 补充

从我的见闻来说，大多数的嵌入式工程师都在强调``cross-compiler-gcc``而不是``cross-compiler-make``，说的更直白一点是``cross-compiler-qmake``，对于一款产品来说，如果它是嵌入式的，是需要图形化界面的，那么交叉qmake是非常必要的，并且带图形化的产品的市场是不小的，即使不带图形化，也能用qmake或cmake实现更加大的项目，开发的效率将远大于手写makefile。以上纯属个人见解，如有冒犯，不胜感激。